// 멀티 스레드 적용 후
package com.eomcs.concurrent.ex1;

public class Exam0120 {

  static class MyThread extends Thread {
    @Override
    public void run() {
      // 기존 실행 흐름과 분리하여 따로 실행시킬 코드를
      // 이 메서드에 둔다.
      for (int i = 0; i < 1000; i++) {
        System.out.println("==> " + i);
      }
    }
  }

  public static void main(String[] args) {
    // 코드 실행 라인을 새로 만들어 따로 실행한다.
    // 스레드는 비동기로 동작한다.
    // 스레드에 작업을 시킨 후, 그 스레드가 작업이 끝날 때까지 기다리지 않고 즉시 리턴한다.
    // 따라서 스레드 작업과 main()의 코드가 병행(concurrent)으로 실행한다.
    new MyThread().start();

    for (int i = 0; i < 1000; i++) {
      System.out.println(">>> " + i);
    }
  }

}

// 멀티 태스킹(Multi-tasking)
// 한 개의 CPU가 여러 코드를 동시에 실행하는 것
// 실제로는 일정한 시간을 쪼개 이 코드와 저 코드를 왔다갔다 하면서 실행
// 그럼에도 불구, 외부에서 봤을 때 명령어가 동시에 실행되는 것 처럼 보임

// CPU/Process Scheduling
// - CPU 실행 시간 쪼개 코드 실행하는 방법
// 1. Round-Robin : Windows
// - CPU 실행 시간을 일정하게 쪼개 각 코드에 분배하는 방식
// 2. Priority 방식 : Unix/Linux
// - 우선 순위가 높은 코드에 더 많은 실행 시간 배정하는 방식
// - 우선 순위가 낮은 프로그램인 경우, CPU 시간을 배정받지 못하는 문제 발생
// -> CPU 시간을 배정받지 못할 때 마다 우선 순위를 높여 언젠가는 실행되게 만듬 => 3. Aging 방식

// 멀티태스킹의 구현 방법
// 1) 멀티 프로세싱
// - 프로세스(실행 중인 프로그램)를 복제하여 분기 -> 분기된 프로세스를 실행시켜 작업을 동시에 진행하게 함
// - 장점 : 분기하기 쉬움 (프로그래밍(구현) 쉬움)
// - 단점 : 프로세스를 그대로 복제하기 때문에 프로세스가 사용하는 메모리도 그대로 복제, 메모리의 낭비 심함. 복제된 프로세스는 독립적이기 때문에 실행종료할 때도 일일히
// 종료해야 함.
// 2) 멀티 스레딩
// - 특정 코드만 분리하여 실행 -> 프로세스가 사용하는 메모리 공유
// - 장점 : 프로세스의 힙 메모리 공유하여 메모리 낭비 적음, 모든 스레드는 프로세스에 종속되어 프로세스를 종료하면 스레드도 자동 종료

// main() 메서드를 실행하는 기본 실행 흐름에서 새로운 실행 흐름으로 분기하고 싶다면,
// Thread 클래스에 분기해서 실행할 코드를 담으면 된다.
// 그러면 두 개의 실행 흐름이 서로 왔다 갔다 하면서 실행된다.


